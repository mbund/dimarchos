// Code generated by bpf2go; DO NOT EDIT.
//go:build (mips || mips64 || ppc64 || s390x) && linux

package objs

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

type ContainerQnameKey struct{ Qname [256]uint8 }

// LoadContainer returns the embedded CollectionSpec for Container.
func LoadContainer() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_ContainerBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load Container: %w", err)
	}

	return spec, err
}

// LoadContainerObjects loads Container and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*ContainerObjects
//	*ContainerPrograms
//	*ContainerMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func LoadContainerObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := LoadContainer()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// ContainerSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type ContainerSpecs struct {
	ContainerProgramSpecs
	ContainerMapSpecs
	ContainerVariableSpecs
}

// ContainerProgramSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type ContainerProgramSpecs struct {
	NetkitPeer    *ebpf.ProgramSpec `ebpf:"netkit_peer"`
	NetkitPrimary *ebpf.ProgramSpec `ebpf:"netkit_primary"`
}

// ContainerMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type ContainerMapSpecs struct {
	QnameMap *ebpf.MapSpec `ebpf:"qname_map"`
}

// ContainerVariableSpecs contains global variables before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type ContainerVariableSpecs struct {
	EgressPktCount  *ebpf.VariableSpec `ebpf:"egress_pkt_count"`
	IngressPktCount *ebpf.VariableSpec `ebpf:"ingress_pkt_count"`
}

// ContainerObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to LoadContainerObjects or ebpf.CollectionSpec.LoadAndAssign.
type ContainerObjects struct {
	ContainerPrograms
	ContainerMaps
	ContainerVariables
}

func (o *ContainerObjects) Close() error {
	return _ContainerClose(
		&o.ContainerPrograms,
		&o.ContainerMaps,
	)
}

// ContainerMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to LoadContainerObjects or ebpf.CollectionSpec.LoadAndAssign.
type ContainerMaps struct {
	QnameMap *ebpf.Map `ebpf:"qname_map"`
}

func (m *ContainerMaps) Close() error {
	return _ContainerClose(
		m.QnameMap,
	)
}

// ContainerVariables contains all global variables after they have been loaded into the kernel.
//
// It can be passed to LoadContainerObjects or ebpf.CollectionSpec.LoadAndAssign.
type ContainerVariables struct {
	EgressPktCount  *ebpf.Variable `ebpf:"egress_pkt_count"`
	IngressPktCount *ebpf.Variable `ebpf:"ingress_pkt_count"`
}

// ContainerPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to LoadContainerObjects or ebpf.CollectionSpec.LoadAndAssign.
type ContainerPrograms struct {
	NetkitPeer    *ebpf.Program `ebpf:"netkit_peer"`
	NetkitPrimary *ebpf.Program `ebpf:"netkit_primary"`
}

func (p *ContainerPrograms) Close() error {
	return _ContainerClose(
		p.NetkitPeer,
		p.NetkitPrimary,
	)
}

func _ContainerClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed container_bpfeb.o
var _ContainerBytes []byte
